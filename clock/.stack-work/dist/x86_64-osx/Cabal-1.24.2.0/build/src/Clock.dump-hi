
==================== FINAL INTERFACE ====================
2017-10-08 09:02:22.382398 UTC

interface clock-1.0.1.3-8mYWAACzng42FmIBvJ0myl:Clock 8002
  interface hash: e89c8d917b574ee7cda5ef246d8f487b
  ABI hash: f25af3f6a11a27e11452db4931b71409
  export-list hash: 158d8b94633060fac4debd95f48c2e44
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: fb51b1dff9ca8f10e562d08f326b2707
  sig of: Nothing
  used TH splices: False
  where
exports:
  Clock.clockHour
  Clock.clockMin
  Clock.fromHourMin
  Clock.toString
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:Text.Printf 6701574960cd2af960fec5d940be0c25
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
c11c93b28438cdf7c0721028d27ca07b
  $fEqClock :: GHC.Classes.Eq Clock.Clock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock Clock.$fEqClock_$c== Clock.$fEqClock_$c/= -}
c11c93b28438cdf7c0721028d27ca07b
  $fEqClock_$c/= :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.neInt
                  `cast`
                (Sym (Clock.N:Clock[0])
                 ->_R Sym (Clock.N:Clock[0])
                 ->_R <GHC.Types.Bool>_R) -}
c11c93b28438cdf7c0721028d27ca07b
  $fEqClock_$c== :: Clock.Clock -> Clock.Clock -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.eqInt
                  `cast`
                (Sym (Clock.N:Clock[0])
                 ->_R Sym (Clock.N:Clock[0])
                 ->_R <GHC.Types.Bool>_R) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock :: GHC.Num.Num Clock.Clock
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock
                  Clock.$fNumClock_$c+
                  Clock.$fNumClock_$c-
                  Clock.$fNumClock_$c*
                  Clock.$fNumClock_$cnegate
                  (GHC.Base.id @ Clock.Clock)
                  Clock.$fNumClock_$csignum
                  Clock.$fNumClock_$cfromInteger -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock1 :: Clock.Clock -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (1, True, True)
                (\ (ds :: Clock.Clock) -> Clock.$fNumClock2) -}
659eb4d04b5a10eaed32ebeb1c3fbc78
  $fNumClock2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock_$c* :: Clock.Clock -> Clock.Clock -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Clock.Clock) (ds1 :: Clock.Clock) ->
                 Clock.fromMin
                   (GHC.Num.$fNumInt_$c*
                      ds `cast` (Clock.N:Clock[0])
                      ds1 `cast` (Clock.N:Clock[0]))) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock_$c+ :: Clock.Clock -> Clock.Clock -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Clock.Clock) (ds1 :: Clock.Clock) ->
                 Clock.fromMin
                   (GHC.Num.$fNumInt_$c+
                      ds `cast` (Clock.N:Clock[0])
                      ds1 `cast` (Clock.N:Clock[0]))) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock_$c- :: Clock.Clock -> Clock.Clock -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Clock.Clock) (y :: Clock.Clock) ->
                 Clock.$fNumClock_$c+ x (Clock.$fNumClock_$cnegate y)) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock_$cfromInteger :: GHC.Integer.Type.Integer -> Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (i :: GHC.Integer.Type.Integer) ->
                 Clock.fromMin (GHC.Num.$fNumInt_$cfromInteger i)) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock_$cnegate :: Clock.Clock -> Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds `cast` (Clock.N:Clock[0]) of wild1 { GHC.Types.I# y ->
                 Clock.fromMin (GHC.Types.I# (GHC.Prim.-# 1440# y)) }) -}
c11c93b28438cdf7c0721028d27ca07b
  $fNumClock_$csignum :: Clock.Clock -> Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m,
     Unfolding: InlineRule (0, True, True)
                Clock.$fNumClock1
                  `cast`
                (<Clock.Clock>_R ->_R Sym (Clock.N:Clock[0])) -}
c11c93b28438cdf7c0721028d27ca07b
  $fShowClock :: GHC.Show.Show Clock.Clock
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Clock.Clock
                  Clock.$fShowClock_$cshowsPrec
                  Clock.$fShowClock_$cshow
                  Clock.$fShowClock_$cshowList -}
c11c93b28438cdf7c0721028d27ca07b
  $fShowClock1 :: Clock.Clock -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Clock.Clock) (w1 :: GHC.Base.String) ->
                 Clock.$w$cshowsPrec 0# w w1) -}
8cbb3fd2e60eb1171901d1d31b56e7eb
  $fShowClock2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Clock "#) -}
c11c93b28438cdf7c0721028d27ca07b
  $fShowClock_$cshow :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>,
     Unfolding: (\ (x :: Clock.Clock) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Clock.$fShowClock2
                   (case x `cast` (Clock.N:Clock[0]) of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           11#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) -}
c11c93b28438cdf7c0721028d27ca07b
  $fShowClock_$cshowList :: [Clock.Clock] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Clock.Clock
                   Clock.$fShowClock1) -}
c11c93b28438cdf7c0721028d27ca07b
  $fShowClock_$cshowsPrec ::
    GHC.Types.Int -> Clock.Clock -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><L,1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Clock.Clock)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Clock.$w$cshowsPrec ww1 w1 w2 }) -}
c94f32d5b5ba5ee7e9f29eba57d293ab
  $sprintf2 ::
    GHC.Base.String
    -> [Text.Printf.UPrintf]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> [GHC.Types.Char]
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U(U)><L,U(U)>,
     Unfolding: (\ (fmts :: GHC.Base.String)
                   (args :: [Text.Printf.UPrintf])
                   (a1 :: GHC.Types.Int)
                   (eta :: GHC.Types.Int) ->
                 GHC.Base.map
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   Text.Printf.$fIsCharChar_$cfromChar
                   (Text.Printf.uprintfs
                      fmts
                      (GHC.List.reverse1
                         @ Text.Printf.UPrintf
                         (GHC.Types.:
                            @ (Text.Printf.ModifierParser, Text.Printf.FieldFormatter)
                            (Text.Printf.$wparseIntFormat @ GHC.Types.Int,
                             Text.Printf.$fPrintfArgInt_$sformatInt eta)
                            (GHC.Types.:
                               @ (Text.Printf.ModifierParser, Text.Printf.FieldFormatter)
                               (Text.Printf.$wparseIntFormat @ GHC.Types.Int,
                                Text.Printf.$fPrintfArgInt_$sformatInt a1)
                               args))
                         (GHC.Types.[] @ Text.Printf.UPrintf))
                      (GHC.Types.[] @ GHC.Types.Char))) -}
5e2a0b691b80193113098785de22a6b8
  $tc'Clock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12724554157095153077##
                   9782883147375817689##
                   Clock.$trModule
                   Clock.$tc'Clock1) -}
1c1d88d75e6266882334c216553bed05
  $tc'Clock1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Clock"#) -}
fe9a731ac118c6e7aa9f78de6dd8c9ee
  $tcClock :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14250201301327236038##
                   13177912100219079492##
                   Clock.$trModule
                   Clock.$trModule1) -}
86db943362ef8097289f4ec31221cad7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Clock.$trModule2 Clock.$trModule1) -}
a03f50297afc8fc501bcc0661b33c9a6
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Clock"#) -}
7b1fdee885882bead7cc291ad5a74699
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "clock-1.0.1.3-8mYWAACzng42FmIBvJ0myl"#) -}
c11c93b28438cdf7c0721028d27ca07b
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Clock.Clock -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <S,U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (w :: Clock.Clock)
                   (w1 :: GHC.Base.String) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Clock.$fShowClock2
                        (case w `cast` (Clock.N:Clock[0]) of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11# ww3 w1 of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Clock.$fShowClock2
                           (case w `cast` (Clock.N:Clock[0]) of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11#
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.shows4
                                      w1) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
304c9d4e0db4cab671ae8932101281b2
  $wfromMin :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,U>, Inline: [0] -}
c11c93b28438cdf7c0721028d27ca07b
  newtype Clock = Clock GHC.Types.Int
2615ab430b3da77e0f77cbe0febb0a89
  clockHour :: Clock.Clock -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Clock.Clock) ->
                 case w `cast` (Clock.N:Clock[0]) of ww { GHC.Types.I# ww1 ->
                 case GHC.Classes.divInt# ww1 60# of ww4 { DEFAULT ->
                 case GHC.Classes.modInt# ww4 24# of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } } }) -}
79b1b9b6de997b3edb1b7dc8d94395b5
  clockMin :: Clock.Clock -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Clock.Clock) ->
                 case ds `cast` (Clock.N:Clock[0]) of wild1 { GHC.Types.I# x ->
                 case GHC.Classes.modInt# x 60# of ww2 { DEFAULT ->
                 GHC.Types.I# ww2 } }) -}
26f9afc92dc138276104feff7c9472d5
  fromHourMin :: GHC.Types.Int -> GHC.Types.Int -> Clock.Clock
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (hour :: GHC.Types.Int) (min :: GHC.Types.Int) ->
                 case hour of wild { GHC.Types.I# x ->
                 case min of wild1 { GHC.Types.I# y ->
                 Clock.fromMin
                   (GHC.Types.I# (GHC.Prim.+# (GHC.Prim.*# x 60#) y)) } }) -}
c11c93b28438cdf7c0721028d27ca07b
  fromMin :: GHC.Types.Int -> Clock.Clock
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case Clock.$wfromMin ww1 of ww2 { DEFAULT ->
                 (GHC.Types.I# ww2) `cast` (Sym (Clock.N:Clock[0])) } }) -}
a19208bb546204e33226033328ded88e
  toString :: Clock.Clock -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U(U)>,
     Unfolding: (\ (clock :: Clock.Clock) ->
                 Clock.$sprintf2
                   Clock.toString1
                   (GHC.Types.[] @ Text.Printf.UPrintf)
                   (Clock.clockHour clock)
                   (Clock.clockMin clock)) -}
3817cf5b36c210cfd89ea9b8cc5d2cc1
  toString1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "%02d:%02d"#) -}
instance [safe] GHC.Classes.Eq [Clock.Clock] = Clock.$fEqClock
instance [safe] GHC.Num.Num [Clock.Clock] = Clock.$fNumClock
instance [safe] GHC.Show.Show [Clock.Clock] = Clock.$fShowClock
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

